{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-64da684e8441341f936720eb50c3ad2b5abf3fd3",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/FortunaManager.sol": "project/contracts/FortunaManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/access/Admin.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title Admin\n * @notice Provides basic ownership and admin role functionality.\n */\ncontract Admin {\n    address public owner;\n    mapping(address => bool) public admins;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event AdminAdded(address indexed admin);\n    event AdminRemoved(address indexed admin);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Admin: caller is not the owner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender] || msg.sender == owner, \"Admin: caller is not admin\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 OWNER FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Admin: new owner is zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 ADMIN MANAGEMENT                            */\n    /* -------------------------------------------------------------------------- */\n\n    function addAdmin(address admin) external onlyOwner {\n        require(admin != address(0), \"Admin: zero address\");\n        admins[admin] = true;\n        emit AdminAdded(admin);\n    }\n\n    function removeAdmin(address admin) external onlyOwner {\n        admins[admin] = false;\n        emit AdminRemoved(admin);\n    }\n}\n"
      },
      "project/contracts/FortunaManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./libraries/Types.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/Events.sol\";\nimport \"./IFortunaManager.sol\";\nimport \"./access/Admin.sol\";\n\ncontract FortunaManager is IFortunaManager, Admin {\n    mapping(uint256 => Types.RoundInfo) private _rounds;\n    mapping(uint256 => address[]) private _participants;\n    mapping(uint256 => mapping(address => bool)) private _hasEntered;\n    mapping(uint256 => uint32) private _maxParticipants;\n    mapping(uint256 => bool) private _roundExists;\n\n    uint256 private _protocolFees;\n    address public core;\n\n    modifier onlyCore() {\n        if (msg.sender != core) revert Errors.OnlyCoreCanCall();\n        _;\n    }\n\n    function setCore(address _core) external onlyAdmin {\n        if (_core == address(0)) revert Errors.InvalidAddress();\n        core = _core;\n        emit Events.CoreUpdated(_core);\n    }\n\n    function createRound(\n        uint256 roundId,\n        uint64 closeTime,\n        uint256 entryPrice,\n        uint32 maxParticipants\n    ) external override onlyCore {\n        if (_roundExists[roundId]) revert Errors.InvalidOperation();\n        if (closeTime <= block.timestamp) revert Errors.InvalidCloseTime();\n\n        _rounds[roundId] = Types.RoundInfo({\n            roundId: roundId,\n            startTimestamp: block.timestamp,\n            endTimestamp: closeTime,\n            entryFee: entryPrice,\n            prizePool: 0,\n            playerCount: 0,\n            isClosed: false,\n            winner: address(0)\n        });\n\n        _roundExists[roundId] = true;\n        _maxParticipants[roundId] = maxParticipants;\n\n        emit Events.NewRoundCreated(roundId, block.timestamp);\n    }\n\n    function registerEntry(uint256 roundId, address player) external override onlyCore {\n        if (!_roundExists[roundId]) revert Errors.InvalidRoundId();\n        Types.RoundInfo storage r = _rounds[roundId];\n\n        if (r.isClosed) revert Errors.RoundAlreadyClosed();\n        if (block.timestamp >= r.endTimestamp) revert Errors.RoundExpired();\n        if (_participants[roundId].length >= _maxParticipants[roundId]) revert Errors.RoundFull();\n        if (_hasEntered[roundId][player]) revert Errors.InvalidOperation();\n\n        _participants[roundId].push(player);\n        _hasEntered[roundId][player] = true;\n        r.playerCount += 1;\n        r.prizePool += r.entryFee;\n\n        _protocolFees += r.entryFee;\n\n        emit Events.PlayerJoined(roundId, player, r.entryFee);\n    }\n\n    function closeRound(uint256 roundId) external override onlyCore {\n        if (!_roundExists[roundId]) revert Errors.InvalidRoundId();\n        Types.RoundInfo storage r = _rounds[roundId];\n\n        if (r.isClosed) revert Errors.RoundAlreadyClosed();\n        if (block.timestamp < r.endTimestamp) revert Errors.RoundNotExpired();\n\n        r.isClosed = true;\n\n        emit Events.RoundClosed(roundId, r.playerCount, r.prizePool);\n    }\n\n    function setWinner(uint256 roundId, address winner) external override onlyCore {\n        if (!_roundExists[roundId]) revert Errors.InvalidRoundId();\n        Types.RoundInfo storage r = _rounds[roundId];\n\n        if (!r.isClosed) revert Errors.RoundNotExpired();\n        if (winner == address(0)) revert Errors.InvalidAddress();\n\n        r.winner = winner;\n\n        emit Events.WinnerSelected(roundId, winner, r.prizePool);\n    }\n\n    function withdrawProtocolFees(address to) external override onlyAdmin {\n        if (to == address(0)) revert Errors.InvalidAddress();\n        uint256 amount = _protocolFees;\n        _protocolFees = 0;\n\n        (bool sent, ) = to.call{value: amount}(\"\");\n        if (!sent) revert Errors.TransferFailed();\n\n        emit Events.ProtocolFeeWithdrawn(to, amount);\n    }\n\n    function getRound(uint256 roundId) external view override returns (Types.RoundInfo memory) {\n        return _rounds[roundId];\n    }\n\n    function getParticipants(uint256 roundId) external view override returns (address[] memory) {\n        return _participants[roundId];\n    }\n\n    function hasEntered(uint256 roundId, address player) external view override returns (bool) {\n        return _hasEntered[roundId][player];\n    }\n\n    function getProtocolFees() external view override returns (uint256) {\n        return _protocolFees;\n    }\n\n    function roundExists(uint256 roundId) external view override returns (bool) {\n        return _roundExists[roundId];\n    }\n\n    function totalParticipants(uint256 roundId) external view override returns (uint256) {\n        return _participants[roundId].length;\n    }\n\n    function getMaxParticipants(uint256 roundId) external view returns (uint32) {\n        return _maxParticipants[roundId];\n    }\n}\n"
      },
      "project/contracts/IFortunaManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./libraries/Types.sol\";\n\ninterface IFortunaManager {\n    function createRound(\n        uint256 roundId,\n        uint64 closeTime,\n        uint256 entryPrice,\n        uint32 maxParticipants\n    ) external;\n\n    function registerEntry(uint256 roundId, address player) external;\n\n    function closeRound(uint256 roundId) external;\n\n    function setWinner(uint256 roundId, address winner) external;\n\n    function withdrawProtocolFees(address to) external;\n\n    function getRound(uint256 roundId) external view returns (Types.RoundInfo memory);\n\n    function getParticipants(uint256 roundId)\n        external\n        view\n        returns (address[] memory);\n\n    function hasEntered(uint256 roundId, address player)\n        external\n        view\n        returns (bool);\n\n    function getProtocolFees() external view returns (uint256);\n\n    function roundExists(uint256 roundId) external view returns (bool);\n\n    function totalParticipants(uint256 roundId) external view returns (uint256);\n}\n"
      },
      "project/contracts/libraries/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary Errors {\n    error RoundFull();\n    error RoundNotFull();\n    error RoundAlreadyClosed();\n    error RoundNotExpired();\n    error RoundExpired();\n    error RoundNotStarted();\n    error RoundInProgress();\n    error InvalidRoundId();\n\n    error InvalidEntryFee();\n    error ZeroEntry();\n    error NotEnoughPlayers();\n    error TransferFailed();\n    error RefundFailed();\n\n    error NotOwner();\n    error InvalidFeePercentage();\n    error SystemPaused();\n    error SystemNotPaused();\n\n    error RandomNotRequested();\n    error RandomAlreadyRequested();\n    error RandomPending();\n    error InvalidRandomResponse();\n\n    error NotAuthorized();\n    error OnlyCoreCanCall();\n    error OnlyManagerCanCall();\n\n    error InvalidAddress();\n    error InvalidOperation();\n    error InvalidState();\n    error InvalidCloseTime();\n}\n"
      },
      "project/contracts/libraries/Events.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary Events {\n    event PlayerJoined(uint256 indexed roundId, address indexed player, uint256 entryFee);\n    event RoundFull(uint256 indexed roundId);\n    event RoundTimerStarted(uint256 indexed roundId, uint256 startTimestamp, uint256 endTimestamp);\n    event RoundClosed(uint256 indexed roundId, uint256 totalPlayers, uint256 prizePool);\n    event NewRoundCreated(uint256 indexed roundId, uint256 timestamp);\n    event RandomnessRequested(uint256 indexed roundId, bytes32 indexed requestId);\n    event RandomnessFulfilled(uint256 indexed roundId, uint256 randomness);\n    event WinnerSelected(uint256 indexed roundId, address indexed winner, uint256 prizeAmount);\n    event PlatformFeeCollected(uint256 indexed roundId, uint256 amount);\n    event PlayerRefunded(uint256 indexed roundId, address indexed player, uint256 amount);\n    event EntryFeeUpdated(uint256 oldFee, uint256 newFee);\n    event PlatformFeeUpdated(uint256 oldFee, uint256 newFee);\n    event SystemPaused(address indexed by);\n    event SystemUnpaused(address indexed by);\n    event ProtocolFeeWithdrawn(address indexed to, uint256 amount);\n    event CoreUpdated(address indexed newCore);\n}\n"
      },
      "project/contracts/libraries/Types.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary Types {\n    struct Round {\n        bool exists;\n        bool closed;\n        address winner;\n        uint64 closeTime;\n        uint256 entryPrice;\n        uint32 maxParticipants;\n        uint32 participantCount;\n    }\n\n    struct RoundInfo {\n        uint256 roundId;\n        uint256 startTimestamp;\n        uint256 endTimestamp;\n        uint256 entryFee;\n        uint256 prizePool;\n        uint256 playerCount;\n        bool isClosed;\n        address winner;\n    }\n\n    struct PlayerInfo {\n        address player;\n        uint256 entryTimestamp;\n        uint256 roundId;\n        bool refunded;\n    }\n\n    struct RandomRequest {\n        bytes32 requestId;\n        bool fulfilled;\n        uint256 randomness;\n    }\n\n    struct SystemConfig {\n        uint256 entryFee;\n        uint256 platformFeeBP;\n        bool isPaused;\n    }\n}\n"
      }
    }
  }
}